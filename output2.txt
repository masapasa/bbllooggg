"/Users/aswin/Documents/blogg/src/env.mjs" ```import { z } from "zod";

/**
 * Specify your server-side environment variables schema here. This way you can ensure the app isn't
 * built with invalid env vars.
 */
const server = z.object({
    DATABASE_URL: z.string().url(),
    DIRECT_URL: z.string().url(),

    NODE_ENV: z.enum(["development", "test", "production"]),
});

/**
 * Specify your client-side environment variables schema here. This way you can ensure the app isn't
 * built with invalid env vars. To expose them to the client, prefix them with `NEXT_PUBLIC_`.
 */
const client = z.object({
    NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string(),
    NEXT_PUBLIC_SUPABASE_PROJECT_URL: z.string().url(),
    NEXT_PUBLIC_SUPABASE_SERVICE_KEY: z.string(),
    VERCEL_URL: z.string().optional(),
});

/**
 * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.
 * middlewares) or client-side so we need to destruct manually.
 *
 * @type {Record<keyof z.infer<typeof server> | keyof z.infer<typeof client>, string | undefined>}
 */
const processEnv = {
    DATABASE_URL: process.env.DATABASE_URL,
    DIRECT_URL: process.env.DIRECT_URL,

    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    NEXT_PUBLIC_SUPABASE_PROJECT_URL:
        process.env.NEXT_PUBLIC_SUPABASE_PROJECT_URL,
    NEXT_PUBLIC_SUPABASE_SERVICE_KEY:
        process.env.NEXT_PUBLIC_SUPABASE_SERVICE_KEY,

    NODE_ENV: process.env.NODE_ENV,
    VERCEL_URL: process.env.VERCEL_URL,
    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,
};

// Don't touch the part below
// --------------------------

const merged = server.merge(client);

/** @typedef {z.input<typeof merged>} MergedInput */
/** @typedef {z.infer<typeof merged>} MergedOutput */
/** @typedef {z.SafeParseReturnType<MergedInput, MergedOutput>} MergedSafeParseReturn */

let env = /** @type {MergedOutput} */ (process.env);

if (!!process.env.SKIP_ENV_VALIDATION == false) {
    const isServer = typeof window === "undefined";

    const parsed = /** @type {MergedSafeParseReturn} */ (
        isServer
            ? merged.safeParse(processEnv) // on server we can validate all env vars
            : client.safeParse(processEnv) // on client we can only validate the ones that are exposed
    );

    if (parsed.success === false) {
        console.error(
            "❌ Invalid environment variables:",
            parsed.error.flatten().fieldErrors
        );
        throw new Error("Invalid environment variables");
    }

    env = new Proxy(parsed.data, {
        get(target, prop) {
            if (typeof prop !== "string") return undefined;
            // Throw a descriptive error if a server-side env var is accessed on the client
            // Otherwise it would just be returning `undefined` and be annoying to debug
            if (!isServer && !prop.startsWith("NEXT_PUBLIC_"))
                throw new Error(
                    process.env.NODE_ENV === "production"
                        ? "❌ Attempted to access a server-side environment variable on the client"
                        : `❌ Attempted to access server-side environment variable '${prop}' on the client`
                );
            return target[/** @type {keyof typeof target} */ (prop)];
        },
    });
}

export { env };
```
"/Users/aswin/Documents/blogg/src/app/layout.tsx" ```"use client";
import {
    ChakraProvider,
    Container,
    DarkMode,
    ColorModeScript,
} from "@chakra-ui/react";
import { api } from "~/utils/api";
import type { ReactNode } from "react";
import { AuthContextProvider } from "~/providers/AuthContextProvider/AuthContextProvider";

// export const metadata = {
//     title: "Next.js",
//     description: "Generated by Next.js",
// };

function RootLayout({ children }: { children: ReactNode }) {
    return (
        <html lang="en">
            <body>
                <AuthContextProvider>
                    <ChakraProvider>
                        <Container>
                            <DarkMode>{children}</DarkMode>
                            <ColorModeScript initialColorMode={"dark"} />
                        </Container>
                    </ChakraProvider>
                </AuthContextProvider>
            </body>
        </html>
    );
}

export default api.withTRPC(RootLayout);
```
"/Users/aswin/Documents/blogg/src/app/page.tsx" ```"use client";

import { Spinner, Text, Button } from "@chakra-ui/react";
import { RealtimeChannel } from "@supabase/supabase-js";
import React, { useState } from "react";
import { useCallback, useEffect, useMemo } from "react";
import { PostForm } from "~/components/PostForm";
import { PostList } from "~/components/PostList";
import { WithPrivateRoute } from "~/components/withPrivateRoute";
import { api } from "~/utils/api";
import { supabase } from "~/utils/supabase-client";

const Posts = () => {
    const { data, isLoading, refetch } = api.post.getPosts.useQuery(
        {},
        { refetchOnWindowFocus: false }
    );
    const utils = api.useContext();

    useEffect(() => {
        const channel = supabase
            .channel("any")
            .on(
                "postgres_changes",
                { event: "INSERT", schema: "public", table: "posts" },
                (payload) => {
                    console.log("Change received!", payload);
                    void refetch();
                }
            )
            .subscribe((status) => {
                console.log(status);
                void utils.post.getPosts.invalidate();
            });

        return () => {
            void channel.unsubscribe();
        };
    }, []);

    console.log(supabase.getChannels());

    const logOut = async () => {
        await supabase.auth.signOut();
    };

    return (
        <>
            <Button
                onClick={() => void logOut()}
                size={"xs"}
                w={"100%"}
                my={8}
                variant={"link"}
            >
                Log Out
            </Button>
            <Text fontSize={"4xl"} align="center">
                Create a post
            </Text>
            <PostForm />

            {isLoading && <Spinner />}
            {data && <PostList posts={data} />}
        </>
    );
};

export default WithPrivateRoute(Posts);
```
"/Users/aswin/Documents/blogg/src/app/posts/page.tsx" ```"use client";

import { WithPrivateRoute } from "~/components/withPrivateRoute";
import { Posts } from "~/pageComponents/Posts";

export default WithPrivateRoute(Posts);
```
"/Users/aswin/Documents/blogg/src/app/login/page.tsx" ```"use client";

export { LogIn as default } from "../../pageComponents/LogIn";
```
"/Users/aswin/Documents/blogg/src/app/login/set-profile/page.tsx" ```"use client";

export { ProfileForm as default } from "~/pageComponents/ProfileForm";
```
"/Users/aswin/Documents/blogg/src/providers/AuthContextProvider/AuthContextProvider.tsx" ```import React, { createContext, useContext, useEffect, useState } from "react";

import type { Session, User } from "@supabase/supabase-js";

import { supabase } from "~/utils/supabase-client";
import { redirect } from "next/navigation";

export const AuthContext = createContext<{
    user: User | null;
    session: Session | null;
    isLoading: boolean;
}>({
    user: null,
    session: null,
    isLoading: true,
});

export const AuthContextProvider = ({
    children,
}: {
    children: React.ReactNode;
}) => {
    const [userSession, setUserSession] = useState<Session | null>(null);
    const [user, setUser] = useState<User | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        void supabase.auth.getSession().then(({ data: { session } }) => {
            setUserSession(session);
            setUser(session?.user ?? null);
            setIsLoading(false);
        });

        const { data: authListener } = supabase.auth.onAuthStateChange(
            (event, session) => {
                setUserSession(session);
                setUser(session?.user ?? null);
                setIsLoading(false);
            }
        );

        return () => {
            authListener.subscription.unsubscribe();
        };
    }, []);

    const value = {
        session: userSession,
        user,
        isLoading,
    };

    return (
        <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
    );
};

export const useUser = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error("useUser must be used within a AuthContextProvider.");
    }
    return context;
};
```
"/Users/aswin/Documents/blogg/src/server/db.ts" ```import { PrismaClient } from "@prisma/client";

import { env } from "~/env.mjs";

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log:
      env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  });

if (env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
```
"/Users/aswin/Documents/blogg/src/server/api/trpc.ts" ```/**
 * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:
 * 1. You want to modify request context (see Part 1).
 * 2. You want to create a new middleware or type of procedure (see Part 3).
 *
 * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will
 * need to use are documented accordingly near the end.
 */

/**
 * 1. CONTEXT
 *
 * This section defines the "contexts" that are available in the backend API.
 *
 * These allow you to access things when processing a request, like the database, the session, etc.
 */
import { type CreateNextContextOptions } from "@trpc/server/adapters/next";

import { prisma } from "~/server/db";

type CreateContextOptions = Record<string, never>;

/**
 * This helper generates the "internals" for a tRPC context. If you need to use it, you can export
 * it from here.
 *
 * Examples of things you may need it for:
 * - testing, so we don't have to mock Next.js' req/res
 * - tRPC's `createSSGHelpers`, where we don't have req/res
 *
 * @see https://create.t3.gg/en/usage/trpc#-servertrpccontextts
 */
const createInnerTRPCContext = (_opts: CreateContextOptions) => {
    return {
        prisma,
    };
};

/**
 * This is the actual context you will use in your router. It will be used to process every request
 * that goes through your tRPC endpoint.
 *
 * @see https://trpc.io/docs/context
 */
export const getServiceSupabase = () =>
    createClient<Database>(
        env.NEXT_PUBLIC_SUPABASE_PROJECT_URL,
        env.NEXT_PUBLIC_SUPABASE_SERVICE_KEY,
        {
            auth: {
                autoRefreshToken: false,
                persistSession: false,
            },
        }
    );

export const getUserAsAdmin = async (token: string) => {
    console.log(`token:${token}`);
    const { data, error } = await getServiceSupabase().auth.getUser(token);

    if (error) {
        throw error;
    }

    return data;
};

export const createTRPCContext = async (_opts: CreateNextContextOptions) => {
    const req = _opts.req;
    console.log(req.headers);
    const { user } = req.headers.authorization
        ? await getUserAsAdmin(req.headers.authorization)
        : { user: null };

    return {
        prisma,
        user,
    };
};

/**
 * 2. INITIALIZATION
 *
 * This is where the tRPC API is initialized, connecting the context and transformer. We also parse
 * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation
 * errors on the backend.
 */
import { initTRPC, TRPCError } from "@trpc/server";
import superjson from "superjson";
import { ZodError } from "zod";
import { env } from "~/env.mjs";
import { createClient } from "@supabase/supabase-js";
import { Database } from "~/shared/types/supabase.types";

const t = initTRPC.context<typeof createTRPCContext>().create({
    transformer: superjson,
    errorFormatter({ shape, error }) {
        return {
            ...shape,
            data: {
                ...shape.data,
                zodError:
                    error.cause instanceof ZodError
                        ? error.cause.flatten()
                        : null,
            },
        };
    },
});

/**
 * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)
 *
 * These are the pieces you use to build your tRPC API. You should import these a lot in the
 * "/src/server/api/routers" directory.
 */

/**
 * This is how you create new routers and sub-routers in your tRPC API.
 *
 * @see https://trpc.io/docs/router
 */
export const createTRPCRouter = t.router;

/**
 * Public (unauthenticated) procedure
 *
 * This is the base piece you use to build new queries and mutations on your tRPC API. It does not
 * guarantee that a user querying is authorized, but you can still access user session data if they
 * are logged in.
 */
export const publicProcedure = t.procedure;

const enforceUserIsAuthed = t.middleware(async ({ ctx, next }) => {
    if (!ctx.user) {
        throw new TRPCError({
            code: "UNAUTHORIZED",
        });
    }

    return next({
        ctx: {
            user: ctx.user,
        },
    });
});

export const privateProcedure = t.procedure.use(enforceUserIsAuthed);
```
"/Users/aswin/Documents/blogg/src/server/api/root.ts" ```import { createTRPCRouter } from "~/server/api/trpc";
import { postRouter } from "~/server/api/routers/posts";
import { userRouter } from "~/server/api/routers/users";

/**
 * This is the primary router for your server.
 *
 * All routers added in /api/routers should be manually added here.
 */
export const appRouter = createTRPCRouter({
    post: postRouter,
    user: userRouter,
});

// export type definition of API
export type AppRouter = typeof appRouter;
```
"/Users/aswin/Documents/blogg/src/server/api/utils.ts" ```import { supabase } from "~/utils/supabase-client";

export const uploadFile = async (userId: string, content: File) => {
    const { data, error } = await supabase.storage
        .from("avatars")
        .upload(`${userId}`, content, { upsert: true });

    if (error) return { error };

    const { data: signedURLData, error: signedURLError } =
        await supabase.storage
            .from("avatars")
            .createSignedUrl(data.path, 999_999_999);

    if (signedURLError) return { error: signedURLError };

    return { url: signedURLData.signedUrl };
};
```
"/Users/aswin/Documents/blogg/src/server/api/routers/posts.ts" ```import { z } from "zod";
import { commentValidationSchema } from "~/components/CommentForm";
import { postValidationSchema } from "~/components/PostForm";

import {
    createTRPCRouter,
    privateProcedure,
    publicProcedure,
} from "~/server/api/trpc";

export const postRouter = createTRPCRouter({
    createPost: privateProcedure
        .input(postValidationSchema)
        .mutation(async ({ input, ctx }) => {
            await ctx.prisma.posts.create({
                data: {
                    title: input.title,
                    content: input.content,
                    author_id: ctx.user.id,
                },
            });
        }),
    getPosts: publicProcedure.query(async ({ ctx }) => {
        return await ctx.prisma.posts.findMany({
            include: {
                profiles: {
                    select: {
                        avatar_url: true,
                        username: true,
                    },
                },
                comments: {
                    orderBy: {
                        created_at: "desc",
                    },
                    include: {
                        profiles: {
                            select: {
                                avatar_url: true,
                                username: true,
                            },
                        },
                    },
                },
            },
            orderBy: {
                created_at: "desc",
            },
        });
    }),
    createComment: privateProcedure
        .input(commentValidationSchema)
        .mutation(async ({ input, ctx }) => {
            await ctx.prisma.comments.create({
                data: {
                    content: input.content,
                    post_id: input.postId,
                    author_id: ctx.user.id,
                },
            });
        }),
});
```
"/Users/aswin/Documents/blogg/src/server/api/routers/users.ts" ```import * as Yup from "yup";
import { profileValidationSchema } from "~/pageComponents/ProfileForm";

import { createTRPCRouter, privateProcedure } from "~/server/api/trpc";

export const userRouter = createTRPCRouter({
    getProfile: privateProcedure.query(async ({ ctx }) => {
        return await ctx.prisma.profiles.findUnique({
            where: {
                id: ctx.user.id,
            },
        });
    }),
    updateProfile: privateProcedure
        .input(
            profileValidationSchema.concat(
                Yup.object({
                    avatar_url: Yup.string(),
                })
            )
        )
        .mutation(async ({ input, ctx }) => {
            await ctx.prisma.profiles.update({
                data: {
                    username: input.username,
                    avatar_url: input.avatar_url,
                },
                where: {
                    id: ctx.user.id,
                },
            });
        }),
});
```
"/Users/aswin/Documents/blogg/src/utils/supabase-server.ts" ```import { headers, cookies } from "next/headers";
import { createServerComponentSupabaseClient } from "@supabase/auth-helpers-nextjs";

import type { Database } from "~/shared/types/supabase.types";

export const createClient = () =>
    createServerComponentSupabaseClient<Database>({
        headers,
        cookies,
    });
```
"/Users/aswin/Documents/blogg/src/utils/api.ts" ```/**
 * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which
 * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.
 *
 * We also create a few inference helpers for input and output types.
 */
import { httpBatchLink, loggerLink } from "@trpc/client";
import { createTRPCNext } from "@trpc/next";
import { type inferRouterInputs, type inferRouterOutputs } from "@trpc/server";
import superjson from "superjson";

import { type AppRouter } from "~/server/api/root";
import { supabase } from "./supabase-client";

const getBaseUrl = () => {
    if (typeof window !== "undefined") return ""; // browser should use relative url
    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url
    return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost
};

console.log(getBaseUrl());

/** A set of type-safe react-query hooks for your tRPC API. */
export const api = createTRPCNext<AppRouter>({
    config() {
        return {
            /**
             * Transformer used for data de-serialization from the server.
             *
             * @see https://trpc.io/docs/data-transformers
             */
            transformer: superjson,

            /**
             * Links used to determine request flow from client to server.
             *
             * @see https://trpc.io/docs/links
             */
            links: [
                loggerLink({
                    enabled: (opts) =>
                        process.env.NODE_ENV === "development" ||
                        (opts.direction === "down" &&
                            opts.result instanceof Error),
                }),
                httpBatchLink({
                    url: `${getBaseUrl()}/api/trpc`,
                    async headers() {
                        return {
                            authorization: (await supabase.auth.getSession())
                                .data.session?.access_token,
                        };
                    },
                }),
            ],
        };
    },
    /**
     * Whether tRPC should await queries when server rendering pages.
     *
     * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false
     */
    ssr: false,
});

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```
"/Users/aswin/Documents/blogg/src/utils/supabase-client.ts" ```import { createClient } from "@supabase/supabase-js";
import { env } from "~/env.mjs";

const supabaseUrl = env.NEXT_PUBLIC_SUPABASE_PROJECT_URL;
const supabaseKey = env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseKey);
```
"/Users/aswin/Documents/blogg/src/shared/types/supabase.types.ts" ```export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json }
  | Json[]

export interface Database {
  public: {
    Tables: {
      " posts": {
        Row: {
          content: string | null
          created_at: string
          id: string
          title: string
        }
        Insert: {
          content?: string | null
          created_at?: string
          id?: string
          title: string
        }
        Update: {
          content?: string | null
          created_at?: string
          id?: string
          title?: string
        }
      }
      comments: {
        Row: {
          content: string
          created_at: string
          id: string
          post_id: string
        }
        Insert: {
          content: string
          created_at?: string
          id?: string
          post_id: string
        }
        Update: {
          content?: string
          created_at?: string
          id?: string
          post_id?: string
        }
      }
      profiles: {
        Row: {
          id: string
          updated_at: string | null
          username: string | null
        }
        Insert: {
          id: string
          updated_at?: string | null
          username?: string | null
        }
        Update: {
          id?: string
          updated_at?: string | null
          username?: string | null
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}
```
"/Users/aswin/Documents/blogg/src/pageComponents/LogIn.tsx" ```import { Button, Center, Flex, Stack, Text } from "@chakra-ui/react";
import { createClient } from "@supabase/supabase-js";
import React, { useState } from "react";
import { env } from "~/env.mjs";
import { api } from "~/utils/api";

import { supabase } from "~/utils/supabase-client";

export function LogIn() {
  const [error, setError] = useState<null | string>()
    async function signInWithGoogle() {
        const { data, error } = await supabase.auth.signInWithOAuth({
            provider: "google",
        });
        setError(error?.message)
    }

    return (
        <Flex h={"100vh"} justifyContent={"center"} alignItems={"center"}>
            <Stack spacing={5} justifyContent="center">
                <Text fontSize={"3xl"} align="center" w={450}>
                    Log in with Google
                </Text>
                <Button
                    colorScheme="red"
                    onClick={() => void signInWithGoogle()}
                >
                    Google
                </Button>
                {error && <Text color={"red.300"} align="center">{error}</Text>}
            </Stack>
        </Flex>
    );
}
```
"/Users/aswin/Documents/blogg/src/pageComponents/ProfileForm.tsx" ```import * as Yup from "yup";
import { yupResolver } from "@hookform/resolvers/yup";
import { InputControl, SubmitButton } from "chakra-ui-react-hook-form";
import { useForm } from "react-hook-form";
import { Box, Button, Flex, Stack, Text } from "@chakra-ui/react";
import { api } from "~/utils/api";
import { useUser } from "~/providers/AuthContextProvider/AuthContextProvider";
import { useFilePicker } from "use-file-picker";
import Image from "next/image";
import { WithPrivateRoute } from "~/components/withPrivateRoute";
import { uploadFile } from "~/server/api/utils";
import { useToast } from "@chakra-ui/react";
import { useCallback, useEffect } from "react";
import { redirect } from "next/navigation";
import { useRouter } from "next/navigation";
import { supabase } from "~/utils/supabase-client";

export const profileValidationSchema = Yup.object({
  username: Yup.string().required().min(3).max(280),
});

type ProfileFormValues = Yup.InferType<typeof profileValidationSchema>;

const ProfileFormBase = () => {
  const router = useRouter();
  const userId = useUser().user?.id;
  const utils = api.useContext();
  const { mutateAsync, isLoading } = api.user.updateProfile.useMutation({
    onSuccess: async () => {
      await utils.user.getProfile.invalidate();
      void router.push("/");
    },
    onError: () => {
      openErrorToast();
    },
  });

  const toast = useToast();

  const openErrorToast = () => {
    toast({ title: "Error setting up profile", status: "error" });
  };

  const [openFileSelector, { filesContent, plainFiles, errors }] =
    useFilePicker({
      readAs: "DataURL",
      accept: "image/*",
      multiple: false,
      limitFilesConfig: { max: 1 },
      maxFileSize: 50,
      imageSizeRestrictions: {
        maxHeight: 1000,
        maxWidth: 1000,
        minHeight: 200,
        minWidth: 200,
      },
    });

  const { control, handleSubmit } = useForm<ProfileFormValues>({
    defaultValues: {
      username: "",
    },
    resolver: yupResolver(profileValidationSchema),
  });

  console.log("errors", errors);

  const onSubmit = async (values: ProfileFormValues) => {
    if (!userId) {
      openErrorToast();
      return;
    }

    let url = null;

    const file = plainFiles[0];

    if (file) {
      const { error, url: signedURL } = await uploadFile(userId, file);

      if (error) {
        openErrorToast();
        return;
      }

      url = signedURL;
    }

    void mutateAsync({ ...values, avatar_url: url ?? undefined });
  };

  return (
    <Stack spacing={8}>
      <Text fontSize={"4xl"} align="center">
        Set up your profile
      </Text>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          void handleSubmit(onSubmit)(e);
        }}
      >
        <Stack spacing={4}>
          <InputControl
            control={control}
            name="username"
            label="username"
            inputProps={{ placeholder: "username" }}
          />

          <Button onClick={() => openFileSelector()}>Upload avatar</Button>

          {filesContent.map((file, index) => (
            <Stack
              key={index}
              w={"100%"}
              border={"1px"}
              borderRadius="8"
              padding={4}
              alignItems="center"
              justifyContent={"center"}
              spacing={4}
              borderColor="gray.600"
            >
              <Text>choosed: {file.name}</Text>
              <Image
                alt={file.name}
                src={file.content}
                width={400}
                height={400}
              />
              <br />
            </Stack>
          ))}

          <SubmitButton control={control} isLoading={isLoading}>
            submit
          </SubmitButton>
          {errors.length && (
            <Text color={"red.300"} align="center">
              Error occured, please choose different file.
            </Text>
          )}
        </Stack>
      </form>
    </Stack>
  );
};

export const ProfileForm = WithPrivateRoute(ProfileFormBase);
```
"/Users/aswin/Documents/blogg/src/pageComponents/Posts.tsx" ```import { Spinner, Text } from "@chakra-ui/react";
import { PostForm } from "~/components/PostForm";
import { PostList } from "~/components/PostList";
import { api } from "~/utils/api";

export const Posts = () => {
    const { data, isLoading } = api.post.getPosts.useQuery();

    return (
        <>
            <Text fontSize={"4xl"} align="center">
                Create a post
            </Text>
            <PostForm />
            {isLoading && <Spinner />}
            {data && <PostList posts={data} />}
        </>
    );
};
```
"/Users/aswin/Documents/blogg/src/components/CommentForm.tsx" ```import * as Yup from "yup";
import { yupResolver } from "@hookform/resolvers/yup";
import {
    InputControl,
    SubmitButton,
    TextareaControl,
} from "chakra-ui-react-hook-form";
import { useForm } from "react-hook-form";
import { Stack, useToast } from "@chakra-ui/react";
import { api } from "../utils/api";
import { supabase } from "~/utils/supabase-client";

export const commentValidationSchema = Yup.object({
    content: Yup.string().required().max(280),
    postId: Yup.string().required(),
});

type CommentFormValues = Yup.InferType<typeof commentValidationSchema>;

export const CommentForm = ({
    postId,
    handleModalClose,
}: {
    postId: string;
    handleModalClose: () => void;
}) => {
    const toast = useToast();
    const utils = api.useContext();
    const { mutateAsync, isLoading } = api.post.createComment.useMutation({
        onSuccess: () => {
            void utils.post.getPosts.invalidate();
            void supabase.auth.refreshSession();
            handleModalClose();
        },
        onError: () => {
            toast({ title: "Error commenting", status: "error" });
        },
    });

    const { control, handleSubmit } = useForm<CommentFormValues>({
        defaultValues: { content: "", postId },
        resolver: yupResolver(commentValidationSchema),
    });

    const onSubmit = (values: CommentFormValues) => {
        void mutateAsync(values);
    };

    return (
        <form
            onSubmit={(e) => {
                e.preventDefault();
                void handleSubmit(onSubmit)(e);
            }}
        >
            <Stack spacing={4}>
                <TextareaControl
                    control={control}
                    name="content"
                    textareaProps={{ placeholder: "Your comment" }}
                />

                <SubmitButton control={control} isLoading={isLoading}>
                    submit
                </SubmitButton>
            </Stack>
        </form>
    );
};
```
"/Users/aswin/Documents/blogg/src/components/PostList.tsx" ```import {
    Stack,
    Text,
    Divider,
    Box,
    Flex,
    Button,
    useDisclosure,
    Modal,
    ModalOverlay,
    ModalContent,
    ModalCloseButton,
    ModalHeader,
    ModalBody,
    Avatar,
    ModalFooter,
    Spacer,
} from "@chakra-ui/react";
import { formatDistance } from "date-fns";
import React from "react";
import type { RouterOutputs } from "~/utils/api";
import { CommentForm } from "./CommentForm";

type PostsWithComments = RouterOutputs["post"]["getPosts"];
type Comments = RouterOutputs["post"]["getPosts"][number]["comments"][number];

export function PostList({ posts }: { posts: PostsWithComments }) {
    return (
        <Stack spacing={5}>
            {posts.map(
                ({ title, content, id, created_at, comments, profiles }) => (
                    <Box
                        padding={8}
                        border="1px"
                        borderColor="gray.700"
                        borderRadius={10}
                        key={id}
                    >
                        <Stack spacing={4}>
                            <Flex
                                justifyContent={"space-between"}
                                alignItems="center"
                            >
                                <Flex alignItems={"center"} mr={4} gap={2}>
                                    <Avatar
                                        name={profiles.username ?? "unknown"}
                                        src={profiles.avatar_url ?? ""}
                                    />
                                    <Text color={"gray.400"}>
                                        {profiles.username}
                                    </Text>
                                </Flex>
                                <Text fontWeight={"medium"} fontSize={"2xl"}>
                                    {title}
                                </Text>
                                <Spacer />
                                <Text
                                    fontStyle={"italic"}
                                    fontSize={"smaller"}
                                    color={"gray.500"}
                                >
                                    {formatDistance(created_at, new Date(), {
                                        addSuffix: true,
                                    })}
                                </Text>
                            </Flex>
                            <Text>{content}</Text>
                        </Stack>

                        <CommentList comments={comments} postId={id} />
                    </Box>
                )
            )}
        </Stack>
    );
}

const CommentList = ({
    comments,
    postId,
}: {
    comments: Comments[];
    postId: string;
}) => {
    const { isOpen, onOpen, onClose } = useDisclosure();

    const handleModalClose = () => {
        onClose();
    };

    return (
        <>
            <Stack spacing={4} my={4}>
                <Divider />
                {comments.map(
                    ({
                        content,
                        created_at,
                        id: commentId,
                        profiles,
                    }: Comments) => (
                        <Flex
                            justifyContent={"space-between"}
                            alignItems="center"
                            key={commentId}
                        >
                            <Flex alignItems={"center"} mr={4} gap={2}>
                                <Text color={"gray.400"}>
                                    {profiles.username}
                                </Text>
                            </Flex>
                            <Text>{content}</Text>
                            <Spacer />
                            <Text
                                fontStyle={"italic"}
                                fontSize={"smaller"}
                                color={"gray.500"}
                            >
                                {formatDistance(created_at, new Date(), {
                                    addSuffix: true,
                                })}
                            </Text>
                        </Flex>
                    )
                )}
            </Stack>

            <Button size={"sm"} variant={"solid"} w="100%" onClick={onOpen}>
                Add comment
            </Button>

            <Modal isOpen={isOpen} onClose={onClose}>
                <ModalOverlay />
                <ModalContent>
                    <ModalHeader>Comment the post</ModalHeader>
                    <ModalCloseButton />
                    <ModalBody>
                        <CommentForm
                            handleModalClose={handleModalClose}
                            postId={postId}
                        />
                    </ModalBody>

                    <ModalFooter></ModalFooter>
                </ModalContent>
            </Modal>
        </>
    );
};
```
"/Users/aswin/Documents/blogg/src/components/withPrivateRoute.tsx" ```import { Spinner } from "@chakra-ui/react";
import { redirect, usePathname } from "next/navigation";
import { env } from "~/env.mjs";
import { useUser } from "~/providers/AuthContextProvider/AuthContextProvider";
import { api } from "~/utils/api";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const WithPrivateRoute = (Component: React.FunctionComponent<any>) => {
    const NewComponent = () => {
        const pathName = usePathname();
        const { user, isLoading } = useUser();
        const { data, isLoading: isProfileLoading } =
            api.user.getProfile.useQuery();

        if (isLoading || isProfileLoading) return <Spinner />;
        if (!user) redirect("/login");

        if (!data?.username && pathName !== "/login/set-profile")
            redirect("/login/set-profile");

        return <Component />;
    };

    return NewComponent;
};
```
"/Users/aswin/Documents/blogg/src/components/PostForm.tsx" ```import * as Yup from "yup";
import { yupResolver } from "@hookform/resolvers/yup";
import {
    InputControl,
    SubmitButton,
    TextareaControl,
} from "chakra-ui-react-hook-form";
import { useForm } from "react-hook-form";
import { Spacer, Stack, useToast } from "@chakra-ui/react";
import { api } from "../utils/api";
import { supabase } from "~/utils/supabase-client";

export const postValidationSchema = Yup.object({
    title: Yup.string().required().min(3).max(100),
    content: Yup.string().required().max(280),
});

type PostFormValues = Yup.InferType<typeof postValidationSchema>;

export const PostForm = () => {
    const toast = useToast();
    const utils = api.useContext();
    const { mutateAsync, isLoading } = api.post.createPost.useMutation({
        onSuccess: () => {
            void utils.post.getPosts.invalidate();
        },
        onError: () => {
            toast({
                title: "Error adding post",
                status: "error",
            });
        },
    });

    const { control, handleSubmit } = useForm<PostFormValues>({
        defaultValues: {
            title: "",
            content: "",
        },
        resolver: yupResolver(postValidationSchema),
    });

    const onSubmit = (values: PostFormValues) => {
        void mutateAsync(values);
    };

    return (
        <form
            onSubmit={(e) => {
                e.preventDefault();
                void handleSubmit(onSubmit)(e);
            }}
        >
            <Stack spacing={4}>
                <InputControl
                    control={control}
                    name="title"
                    label="Post title"
                    inputProps={{ placeholder: "post title" }}
                />
                <TextareaControl
                    control={control}
                    name="content"
                    label="Content"
                    textareaProps={{ placeholder: "How was your day?" }}
                />

                <SubmitButton control={control} isLoading={isLoading}>
                    submit
                </SubmitButton>
                <Spacer />
            </Stack>
        </form>
    );
};
```
"/Users/aswin/Documents/blogg/src/pages/api/trpc/[trpc].ts" ```import { createNextApiHandler } from "@trpc/server/adapters/next";

import { env } from "~/env.mjs";
import { createTRPCContext } from "~/server/api/trpc";
import { appRouter } from "~/server/api/root";

// export API handler
export default createNextApiHandler({
  router: appRouter,
  createContext: createTRPCContext,
  onError:
    env.NODE_ENV === "development"
      ? ({ path, error }) => {
          console.error(
            `❌ tRPC failed on ${path ?? "<no-path>"}: ${error.message}`,
          );
        }
      : undefined,
});
```
